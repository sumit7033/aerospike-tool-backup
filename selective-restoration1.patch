diff --git a/Makefile b/Makefile
index 4f438fe..8a47d1c 100644
--- a/Makefile
+++ b/Makefile
@@ -276,7 +276,7 @@ RESTORE_OBJ := $(call src_to_obj, $(RESTORE_SRC))
 RESTORE_DEP := $(call obj_to_dep, $(RESTORE_OBJ))
 
 BACKUP := $(DIR_BIN)/asbackup
-RESTORE := $(DIR_BIN)/asrestore
+RESTORE := $(DIR_BIN)/asSelectiverestore
 TOML := $(DIR_TOML)/libtoml.a
 
 SRCS := $(BACKUP_SRC) $(RESTORE_SRC)
diff --git a/include/restore_config.h b/include/restore_config.h
index 7cb05c3..83f15e6 100644
--- a/include/restore_config.h
+++ b/include/restore_config.h
@@ -68,7 +68,7 @@ extern "C" {
 #define BATCH_SIZE_UNDEFINED -1u
 
 #define DEFAULT_EVENT_LOOPS 1
-
+#define DEFAULT_BIN_NAME "id"
 /*
  * The global restore configuration and stats shared by all restore threads and the counter thread.
  */
@@ -131,6 +131,11 @@ typedef struct restore_config {
 	char *ns_list;
 	// The directory to restore from. `NULL`, when restoring from a single file.
 	char *directory;
+	//selective Restoration
+	char *file_path;
+	bool is_selective_restoration;
+	char *selective_bin_name;
+	bool check_p;
 	// A list of directories to restore from. `NULL`, when restoring from a single file or directory.
 	char *directory_list;
 	// A common path to be prepended to entries in directory_list.
diff --git a/src/restore.c b/src/restore.c
index facb102..6519963 100644
--- a/src/restore.c
+++ b/src/restore.c
@@ -27,13 +27,15 @@
 #include <dec_text.h>
 #include <io_proxy.h>
 #include <utils.h>
+#include <khash.h>
 
 
 //==========================================================
 // Typedefs & constants.
 //
 
-#define OPTIONS_SHORT "-h:Sp:A:U:P::n:d:i:t:vm:B:s:urgN:RILFwVZT:y:z:"
+#define OPTIONS_SHORT "-h:Sp:A:U:P::n:d:i:t:vm:B:s:urgN:RILFwVZT:y:z:c:q"
+KHASH_SET_INIT_INT64(bin_set);
 
 static restore_config_t* g_conf;
 static restore_status_t* g_status;
@@ -65,6 +67,9 @@ static bool restore_indexes(aerospike *as, as_vector *index_vec, as_vector *set_
 static bool restore_udf(aerospike *as, udf_param *udf, uint32_t timeout);
 static bool wait_udf(aerospike *as, udf_param *udf, uint32_t timeout);
 static void sig_hand(int32_t sig);
+int check_bin_value(int64_t bin_temp);
+void read_bin_value();
+
 //static void print_stat(per_thread_context_t *ptc, cf_clock *prev_log,
 //		uint64_t *prev_records,	cf_clock *now, cf_clock *store_time, cf_clock *read_time);
 
@@ -73,6 +78,8 @@ static void sig_hand(int32_t sig);
 // Public API.
 //
 
+khash_t(bin_set)* bin_set_pointer;
+
 int32_t
 restore_main(int32_t argc, char **argv)
 {
@@ -123,6 +130,13 @@ restore_main(int32_t argc, char **argv)
 		goto cleanup2;
 	}
 
+	if(g_conf->is_selective_restoration) {
+		read_bin_value();
+	} else {
+		err("Error while restoring...");
+		exit(1);
+	}
+
 	char (*node_names)[][AS_NODE_NAME_SIZE] = NULL;
 	uint32_t n_node_names = 0;
 
@@ -911,10 +925,21 @@ restore_thread_func(void *cont)
 					ptc.status->skipped_records++;
 					as_record_destroy(&rec);
 				} else {
-					if (!record_uploader_put(&record_uploader, &rec)) {
-						stop();
-						break;
-					}
+					// Selective Restoration.
+					if(check_bin_value(as_record_get_int64(&rec ,g_conf->selective_bin_name, INT64_MAX))) {
+						ver("Record(ns= %s set= %s %s= %"PRId64") Restoring...", rec.key.ns, rec.key.set, g_conf->selective_bin_name
+						,as_record_get_int64(&rec, g_conf->selective_bin_name, INT64_MAX));
+
+						if (!record_uploader_put(&record_uploader, &rec)) {
+							stop();
+							break;
+						}
+
+					} else {
+						ptc.status->skipped_records++;
+						as_record_destroy(&rec);
+						}
+				
 				}
 
 				ptc.status->total_records++;
@@ -1100,6 +1125,10 @@ counter_thread_func(void *cont)
 
 	ver("Leaving counter thread");
 
+	// Destroy the hashSet.
+	ver("Freeing hashset");
+	kh_destroy(bin_set, bin_set_pointer);
+
 	return (void *)EXIT_SUCCESS;
 }
 
@@ -1578,3 +1607,53 @@ sig_hand(int32_t sig)
 	stop();
 }
 
+/*------------------------SelectiveRestorationImpl---------------------*/
+
+// Function to find an ID in the hashset.
+int check_bin_value(int64_t bin_temp) {
+    khint_t k = kh_get(bin_set, bin_set_pointer, bin_temp);
+    return k != kh_end(bin_set_pointer);
+}
+
+// Reads the id from the file and add the id to hashTable.
+void read_bin_value() {
+    struct stat st;
+    if (stat(g_conf->file_path, &st) != 0) {
+        // fprintf(stderr, "Cannot access file/directory: %s\n", g_conf->file_path);
+		err("Cannot access file/directory: %s", g_conf->file_path);
+    	exit(1);
+    }
+
+    if (S_ISDIR(st.st_mode)) {
+		err("%s is a directory, not a file.", g_conf->file_path);
+        exit(1);
+    }
+
+    FILE* file = fopen(g_conf->file_path, "r");
+    if (file == NULL) {
+        fprintf(stderr, "Cannot open file: %s", g_conf->file_path);
+        exit(1);
+    }
+
+	inf("Reading from the file...");
+    char line[25]; 
+    bin_set_pointer = kh_init(bin_set);
+    while (fgets(line, sizeof(line), file)) {
+        int64_t id; 
+		if(sscanf(line, "%" SCNd64, &id) == 1) {
+			int ret; 
+			kh_put(bin_set, bin_set_pointer, id, &ret); 
+			if (ret < 0) {
+				err("Error inserting into hash set");
+				fclose(file);
+				kh_destroy(bin_set, bin_set_pointer);
+				exit(1);
+			}
+			
+
+		}
+			
+    }
+    fclose(file);
+	inf("Reading completed!");
+}
\ No newline at end of file
diff --git a/src/restore_config.c b/src/restore_config.c
index 4b1a6e7..78a38b9 100644
--- a/src/restore_config.c
+++ b/src/restore_config.c
@@ -31,7 +31,7 @@
 // Typedefs & constants.
 //
 
-#define OPTIONS_SHORT "-h:Sp:A:U:P::n:d:i:t:vm:B:s:urgN:RILFwVZT:y:z:"
+#define OPTIONS_SHORT "-h:Sp:A:U:P::n:d:i:t:vm:B:s:urgN:RILFwVZT:y:z:c:q:"
 
 // The C client's version string.
 extern char *aerospike_client_version;
@@ -106,6 +106,7 @@ restore_config_init(int argc, char* argv[], restore_config_t* conf)
 		// asrestore section in config file
 		{ "namespace", required_argument, NULL, 'n' },
 		{ "directory", required_argument, NULL, 'd' },
+		{ "filepath", required_argument, NULL, 'c'},
 		{ "directory-list", required_argument, NULL, COMMAND_OPT_DIRECTORY_LIST },
 		{ "parent-directory", required_argument, NULL, COMMAND_OPT_PARENT_DIRECTORY},
 		{ "input-file", required_argument, NULL, 'i' },
@@ -117,6 +118,7 @@ restore_config_init(int argc, char* argv[], restore_config_t* conf)
 		{ "threads", required_argument, NULL, '_' },
 		{ "machine", required_argument, NULL, 'm' },
 		{ "bin-list", required_argument, NULL, 'B' },
+		{ "restoration-bin-name", optional_argument, NULL, 'q' },
 		{ "set-list", required_argument, NULL, 's' },
 		{ "unique", no_argument, NULL, 'u' },
 		{ "ignore-record-error", no_argument, NULL, 'K'},
@@ -280,6 +282,16 @@ restore_config_init(int argc, char* argv[], restore_config_t* conf)
 			conf->directory = safe_strdup(optarg);
 			break;
 
+		case 'c':
+			conf->file_path = safe_strdup(optarg);
+			conf->is_selective_restoration = true;
+			break;	
+
+		case 'q':
+			conf->selective_bin_name = safe_strdup(optarg);
+			conf->check_p = true;
+			break;		
+
 		case COMMAND_OPT_DIRECTORY_LIST:
 			conf->directory_list = safe_strdup(optarg);
 			break;
@@ -622,6 +634,24 @@ restore_config_init(int argc, char* argv[], restore_config_t* conf)
 		return RESTORE_CONFIG_INIT_FAILURE;
 	}
 
+	if(conf->file_path == NULL) {
+		err("Invalid options: please specify a selective restoration path (-c option).");
+		return RESTORE_CONFIG_INIT_FAILURE;
+	}
+
+	if(conf->set_list == NULL) {
+		err("Invalid options: please specify set (-s option).");
+		return RESTORE_CONFIG_INIT_FAILURE;
+	}
+
+	if(conf->set_list != NULL) {
+		char *temp = strchr(conf->set_list, ',');
+		if(temp != NULL) {
+			err("Invalid argument: please specify set by (-s <set-name> )");
+			return RESTORE_CONFIG_INIT_FAILURE;
+		}
+	}
+
 	if (conf->unique && (conf->replace || conf->no_generation)) {
 		err("Invalid options: --unique is mutually exclusive with --replace and --no-generation.");
 		return RESTORE_CONFIG_INIT_FAILURE;
@@ -726,6 +756,10 @@ restore_config_default(restore_config_t *conf)
 	conf->wait = false;
 	conf->ns_list = NULL;
 	conf->directory = NULL;
+	conf->is_selective_restoration = false;
+	conf->file_path = NULL;
+	conf->selective_bin_name = DEFAULT_BIN_NAME;
+	conf->check_p = false;
 	conf->directory_list = NULL;
 	conf->parent_directory = NULL;
 	conf->input_file = NULL;
@@ -801,6 +835,14 @@ restore_config_destroy(restore_config_t *conf)
 		cf_free(conf->directory);
 	}
 
+	if(conf->file_path != NULL) {
+		cf_free(conf->file_path);
+	}
+
+	if(conf->selective_bin_name != NULL && conf->check_p == true) {
+		cf_free(conf->selective_bin_name);
+	}
+
 	if (conf->directory_list != NULL) {
 		cf_free(conf->directory_list);
 	}
@@ -1003,6 +1045,12 @@ usage(const char *name)
 	fprintf(stdout, "                      A comma seperated list of paths to directories that hold the backup files. Required, \n");
 	fprintf(stdout, "                      unless -i or -d is used. The paths may not contain commas.\n");
 	fprintf(stdout, "                      Example: `asrestore --directory-list /path/to/dir1/,/path/to/dir2`\n");
+	fprintf(stdout, "  -c, --filepath <selective Restoration>\n");
+	fprintf(stdout, "                      It is used give the path of from which to restore. Optional, \n");
+	fprintf(stdout, "                      if not given all the ids will be restored.\n");
+	fprintf(stdout, "  -q, --selective  Restoration Bin Name (ex - id, , set) >\n");
+	fprintf(stdout, "                      It is to specify what the Selective Restoration file contain (ex -id). optional, \n");
+	fprintf(stdout, "                      If not provided then the default bin is id\n");
 	fprintf(stdout, "      --parent-directory <directory>\n");
 	fprintf(stdout, "                      A common root path for all paths used in --directory-list.\n");
 	fprintf(stdout, "                      This path is prepended to all entries in --directory-list.\n");
